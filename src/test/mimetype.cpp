//========================================================================
// Zinc - Unit Testing
// Copyright (c) 2019, Pascal Levy
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//========================================================================

#include "gtest/gtest.h"
#include "mimetype.h"

static unsigned int const text_ascii_length = 186;
static unsigned char const text_ascii[] = {
    0x53, 0x6F, 0x75, 0x76, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x70, 0x6F, 0x75, 0x72, 0x20, 0x73, 0x27, 
    0x61, 0x6D, 0x75, 0x73, 0x65, 0x72, 0x2C, 0x20, 0x6C, 0x65, 0x73, 0x20, 0x68, 0x6F, 0x6D, 0x6D, 
    0x65, 0x73, 0x20, 0x64, 0x27, 0x65, 0x71, 0x75, 0x69, 0x70, 0x61, 0x67, 0x65, 0x0D, 0x0A, 0x50, 
    0x72, 0x65, 0x6E, 0x6E, 0x65, 0x6E, 0x74, 0x20, 0x64, 0x65, 0x73, 0x20, 0x61, 0x6C, 0x62, 0x61, 
    0x74, 0x72, 0x6F, 0x73, 0x2C, 0x20, 0x76, 0x61, 0x73, 0x74, 0x65, 0x73, 0x20, 0x6F, 0x69, 0x73, 
    0x65, 0x61, 0x75, 0x78, 0x20, 0x64, 0x65, 0x73, 0x20, 0x6D, 0x65, 0x72, 0x73, 0x2C, 0x0D, 0x0A, 
    0x51, 0x75, 0x69, 0x20, 0x73, 0x75, 0x69, 0x76, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x69, 0x6E, 0x64, 
    0x6F, 0x6C, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x67, 0x6E, 0x6F, 0x6E, 
    0x73, 0x20, 0x64, 0x65, 0x20, 0x76, 0x6F, 0x79, 0x61, 0x67, 0x65, 0x2C, 0x0D, 0x0A, 0x4C, 0x65, 
    0x20, 0x6E, 0x61, 0x76, 0x69, 0x72, 0x65, 0x20, 0x67, 0x6C, 0x69, 0x73, 0x73, 0x61, 0x6E, 0x74, 
    0x20, 0x73, 0x75, 0x72, 0x20, 0x6C, 0x65, 0x73, 0x20, 0x67, 0x6F, 0x75, 0x66, 0x66, 0x72, 0x65, 
    0x73, 0x20, 0x61, 0x6D, 0x65, 0x72, 0x73, 0x2E, 0x0D, 0x0A, 0x00
};

static unsigned int const text_utf8bom_length = 194;
static unsigned char const text_utf8bom[] = {
    0xEF, 0xBB, 0xBF, 0x53, 0x6F, 0x75, 0x76, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x70, 0x6F, 0x75, 0x72, 
    0x20, 0x73, 0xE2, 0x80, 0x99, 0x61, 0x6D, 0x75, 0x73, 0x65, 0x72, 0x2C, 0x20, 0x6C, 0x65, 0x73, 
    0x20, 0x68, 0x6F, 0x6D, 0x6D, 0x65, 0x73, 0x20, 0x64, 0xE2, 0x80, 0x99, 0xC3, 0xA9, 0x71, 0x75, 
    0x69, 0x70, 0x61, 0x67, 0x65, 0x0D, 0x0A, 0x50, 0x72, 0x65, 0x6E, 0x6E, 0x65, 0x6E, 0x74, 0x20, 
    0x64, 0x65, 0x73, 0x20, 0x61, 0x6C, 0x62, 0x61, 0x74, 0x72, 0x6F, 0x73, 0x2C, 0x20, 0x76, 0x61, 
    0x73, 0x74, 0x65, 0x73, 0x20, 0x6F, 0x69, 0x73, 0x65, 0x61, 0x75, 0x78, 0x20, 0x64, 0x65, 0x73, 
    0x20, 0x6D, 0x65, 0x72, 0x73, 0x2C, 0x0D, 0x0A, 0x51, 0x75, 0x69, 0x20, 0x73, 0x75, 0x69, 0x76, 
    0x65, 0x6E, 0x74, 0x2C, 0x20, 0x69, 0x6E, 0x64, 0x6F, 0x6C, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x63, 
    0x6F, 0x6D, 0x70, 0x61, 0x67, 0x6E, 0x6F, 0x6E, 0x73, 0x20, 0x64, 0x65, 0x20, 0x76, 0x6F, 0x79, 
    0x61, 0x67, 0x65, 0x2C, 0x0D, 0x0A, 0x4C, 0x65, 0x20, 0x6E, 0x61, 0x76, 0x69, 0x72, 0x65, 0x20, 
    0x67, 0x6C, 0x69, 0x73, 0x73, 0x61, 0x6E, 0x74, 0x20, 0x73, 0x75, 0x72, 0x20, 0x6C, 0x65, 0x73, 
    0x20, 0x67, 0x6F, 0x75, 0x66, 0x66, 0x72, 0x65, 0x73, 0x20, 0x61, 0x6D, 0x65, 0x72, 0x73, 0x2E, 
    0x0D, 0x0A, 0x00
};

static unsigned int const text_utf8_length = text_utf8bom_length - 3;
static unsigned char const * text_utf8 = text_utf8bom + 3;

static unsigned int const text_utf16bebom_length = 374;
static unsigned char const text_utf16bebom[] = {
    0xFE, 0xFF, 0x00, 0x53, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x76, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 
    0x00, 0x2C, 0x00, 0x20, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x72, 0x00, 0x20, 0x00, 0x73, 
    0x20, 0x19, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x75, 0x00, 0x73, 0x00, 0x65, 0x00, 0x72, 0x00, 0x2C, 
    0x00, 0x20, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x68, 0x00, 0x6F, 0x00, 0x6D, 
    0x00, 0x6D, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x64, 0x20, 0x19, 0x00, 0xE9, 0x00, 0x71, 
    0x00, 0x75, 0x00, 0x69, 0x00, 0x70, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00, 0x0D, 0x00, 0x0A, 
    0x00, 0x50, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x6E, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 
    0x00, 0x20, 0x00, 0x64, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x62, 
    0x00, 0x61, 0x00, 0x74, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x73, 0x00, 0x2C, 0x00, 0x20, 0x00, 0x76, 
    0x00, 0x61, 0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x69, 
    0x00, 0x73, 0x00, 0x65, 0x00, 0x61, 0x00, 0x75, 0x00, 0x78, 0x00, 0x20, 0x00, 0x64, 0x00, 0x65, 
    0x00, 0x73, 0x00, 0x20, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x2C, 0x00, 0x0D, 
    0x00, 0x0A, 0x00, 0x51, 0x00, 0x75, 0x00, 0x69, 0x00, 0x20, 0x00, 0x73, 0x00, 0x75, 0x00, 0x69, 
    0x00, 0x76, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x2C, 0x00, 0x20, 0x00, 0x69, 0x00, 0x6E, 
    0x00, 0x64, 0x00, 0x6F, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x73, 0x00, 0x20, 
    0x00, 0x63, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x70, 0x00, 0x61, 0x00, 0x67, 0x00, 0x6E, 0x00, 0x6F, 
    0x00, 0x6E, 0x00, 0x73, 0x00, 0x20, 0x00, 0x64, 0x00, 0x65, 0x00, 0x20, 0x00, 0x76, 0x00, 0x6F, 
    0x00, 0x79, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00, 0x2C, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x4C, 
    0x00, 0x65, 0x00, 0x20, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x76, 0x00, 0x69, 0x00, 0x72, 0x00, 0x65, 
    0x00, 0x20, 0x00, 0x67, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x73, 0x00, 0x73, 0x00, 0x61, 0x00, 0x6E, 
    0x00, 0x74, 0x00, 0x20, 0x00, 0x73, 0x00, 0x75, 0x00, 0x72, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x65, 
    0x00, 0x73, 0x00, 0x20, 0x00, 0x67, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x66, 0x00, 0x66, 0x00, 0x72, 
    0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x72, 0x00, 0x73, 
    0x00, 0x2E, 0x00, 0x0D, 0x00, 0x0A, 0x00
};

static unsigned int const text_utf16be_length = text_utf16bebom_length - 2;
static unsigned char const * text_utf16be = text_utf16bebom + 2;

static unsigned int const text_utf16lebom_length = 374;
static unsigned char const text_utf16lebom[] = {
    0xFF, 0xFE, 0x53, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x76, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 0x00, 
    0x2C, 0x00, 0x20, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x72, 0x00, 0x20, 0x00, 0x73, 0x00, 
    0x19, 0x20, 0x61, 0x00, 0x6D, 0x00, 0x75, 0x00, 0x73, 0x00, 0x65, 0x00, 0x72, 0x00, 0x2C, 0x00, 
    0x20, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x68, 0x00, 0x6F, 0x00, 0x6D, 0x00, 
    0x6D, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x64, 0x00, 0x19, 0x20, 0xE9, 0x00, 0x71, 0x00, 
    0x75, 0x00, 0x69, 0x00, 0x70, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00, 0x0D, 0x00, 0x0A, 0x00, 
    0x50, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x6E, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 0x00, 
    0x20, 0x00, 0x64, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x62, 0x00, 
    0x61, 0x00, 0x74, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x73, 0x00, 0x2C, 0x00, 0x20, 0x00, 0x76, 0x00, 
    0x61, 0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x69, 0x00, 
    0x73, 0x00, 0x65, 0x00, 0x61, 0x00, 0x75, 0x00, 0x78, 0x00, 0x20, 0x00, 0x64, 0x00, 0x65, 0x00, 
    0x73, 0x00, 0x20, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x2C, 0x00, 0x0D, 0x00, 
    0x0A, 0x00, 0x51, 0x00, 0x75, 0x00, 0x69, 0x00, 0x20, 0x00, 0x73, 0x00, 0x75, 0x00, 0x69, 0x00, 
    0x76, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x2C, 0x00, 0x20, 0x00, 0x69, 0x00, 0x6E, 0x00, 
    0x64, 0x00, 0x6F, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x73, 0x00, 0x20, 0x00, 
    0x63, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x70, 0x00, 0x61, 0x00, 0x67, 0x00, 0x6E, 0x00, 0x6F, 0x00, 
    0x6E, 0x00, 0x73, 0x00, 0x20, 0x00, 0x64, 0x00, 0x65, 0x00, 0x20, 0x00, 0x76, 0x00, 0x6F, 0x00, 
    0x79, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00, 0x2C, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x4C, 0x00, 
    0x65, 0x00, 0x20, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x76, 0x00, 0x69, 0x00, 0x72, 0x00, 0x65, 0x00, 
    0x20, 0x00, 0x67, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x73, 0x00, 0x73, 0x00, 0x61, 0x00, 0x6E, 0x00, 
    0x74, 0x00, 0x20, 0x00, 0x73, 0x00, 0x75, 0x00, 0x72, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x65, 0x00, 
    0x73, 0x00, 0x20, 0x00, 0x67, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x66, 0x00, 0x66, 0x00, 0x72, 0x00, 
    0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 
    0x2E, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x00
};

static unsigned int const text_utf16le_length = text_utf16lebom_length - 2;
static unsigned char const * text_utf16le = text_utf16lebom + 2;

//--------------------------------------------------------------
// Test the isValidUnicodeChar() function.
//--------------------------------------------------------------

TEST(MIME, isValidUnicodeChar) {
    EXPECT_FALSE(isValidUnicodeChar(0));
    EXPECT_FALSE(isValidUnicodeChar(1));
    EXPECT_FALSE(isValidUnicodeChar(2));
    EXPECT_FALSE(isValidUnicodeChar(3));
    EXPECT_FALSE(isValidUnicodeChar(4));
    EXPECT_FALSE(isValidUnicodeChar(5));
    EXPECT_FALSE(isValidUnicodeChar(6));
    EXPECT_TRUE (isValidUnicodeChar(7));
    EXPECT_TRUE (isValidUnicodeChar(8));
    EXPECT_TRUE (isValidUnicodeChar(9));
    EXPECT_TRUE (isValidUnicodeChar(10));
    EXPECT_TRUE (isValidUnicodeChar(11));
    EXPECT_TRUE (isValidUnicodeChar(12));
    EXPECT_TRUE (isValidUnicodeChar(13));
    EXPECT_FALSE(isValidUnicodeChar(14));
    EXPECT_FALSE(isValidUnicodeChar(15));
    EXPECT_FALSE(isValidUnicodeChar(16));
    EXPECT_FALSE(isValidUnicodeChar(17));
    EXPECT_FALSE(isValidUnicodeChar(18));
    EXPECT_FALSE(isValidUnicodeChar(19));
    EXPECT_FALSE(isValidUnicodeChar(20));
    EXPECT_FALSE(isValidUnicodeChar(21));
    EXPECT_FALSE(isValidUnicodeChar(22));
    EXPECT_FALSE(isValidUnicodeChar(23));
    EXPECT_FALSE(isValidUnicodeChar(24));
    EXPECT_FALSE(isValidUnicodeChar(25));
    EXPECT_FALSE(isValidUnicodeChar(26));
    EXPECT_TRUE (isValidUnicodeChar(27));
    EXPECT_FALSE(isValidUnicodeChar(28));
    EXPECT_FALSE(isValidUnicodeChar(29));
    EXPECT_FALSE(isValidUnicodeChar(30));
    EXPECT_FALSE(isValidUnicodeChar(31));

    EXPECT_TRUE (isValidUnicodeChar(0x20));
    EXPECT_TRUE (isValidUnicodeChar(0x2FA1F));
    EXPECT_FALSE(isValidUnicodeChar(0x2FA20));
    EXPECT_FALSE(isValidUnicodeChar(0x30000));
    EXPECT_FALSE(isValidUnicodeChar(0x40000));
    EXPECT_FALSE(isValidUnicodeChar(0x50000));
    EXPECT_FALSE(isValidUnicodeChar(0x60000));
    EXPECT_FALSE(isValidUnicodeChar(0x70000));
    EXPECT_FALSE(isValidUnicodeChar(0x80000));
    EXPECT_FALSE(isValidUnicodeChar(0x90000));
    EXPECT_FALSE(isValidUnicodeChar(0xA0000));
    EXPECT_FALSE(isValidUnicodeChar(0xB0000));
    EXPECT_FALSE(isValidUnicodeChar(0xC0000));
    EXPECT_FALSE(isValidUnicodeChar(0xD0000));
    EXPECT_TRUE (isValidUnicodeChar(0xE0000));
    EXPECT_TRUE (isValidUnicodeChar(0xE01EF));
    EXPECT_FALSE(isValidUnicodeChar(0xE01F0));
    EXPECT_FALSE(isValidUnicodeChar(0xEFFFF));
    EXPECT_TRUE (isValidUnicodeChar(0xF0000));
    EXPECT_TRUE (isValidUnicodeChar(0x10FFFF));
    EXPECT_FALSE(isValidUnicodeChar(0x110000));
    EXPECT_FALSE(isValidUnicodeChar(0x120000));
    EXPECT_FALSE(isValidUnicodeChar(0x10000000));
    EXPECT_FALSE(isValidUnicodeChar(0xFFFFFFFF));
}

//--------------------------------------------------------------
// Test the isUTF8() function.
//--------------------------------------------------------------

TEST(MIME, isUTF8) {
    bool ascii;
    EXPECT_TRUE (isUTF8((char const *) text_ascii,      text_ascii_length,      &ascii) && ascii);
    EXPECT_TRUE (isUTF8((char const *) text_utf8,       text_utf8_length,       &ascii) && !ascii);
    EXPECT_TRUE (isUTF8((char const *) text_utf8bom,    text_utf8bom_length,    &ascii) && !ascii);
    EXPECT_FALSE(isUTF8((char const *) text_utf16le,    text_utf16le_length,    &ascii));
    EXPECT_FALSE(isUTF8((char const *) text_utf16lebom, text_utf16lebom_length, &ascii));
    EXPECT_FALSE(isUTF8((char const *) text_utf16be,    text_utf16be_length,    &ascii));
    EXPECT_FALSE(isUTF8((char const *) text_utf16bebom, text_utf16bebom_length, &ascii));
}

//--------------------------------------------------------------
// Test the isUTF16() function.
//--------------------------------------------------------------

TEST(MIME, isUTF16) {
    EXPECT_FALSE(isUTF16((char const *) text_ascii,      text_ascii_length,      false));
    EXPECT_FALSE(isUTF16((char const *) text_utf8,       text_utf8_length,       false));
    EXPECT_FALSE(isUTF16((char const *) text_utf8bom,    text_utf8bom_length,    false));
    EXPECT_TRUE (isUTF16((char const *) text_utf16le,    text_utf16le_length,    false));
    EXPECT_TRUE (isUTF16((char const *) text_utf16lebom, text_utf16lebom_length, false));
    EXPECT_FALSE(isUTF16((char const *) text_utf16be,    text_utf16be_length,    false));
    EXPECT_FALSE(isUTF16((char const *) text_utf16bebom, text_utf16bebom_length, false));

    EXPECT_FALSE(isUTF16((char const *) text_ascii,      text_ascii_length,      true));
    EXPECT_FALSE(isUTF16((char const *) text_utf8,       text_utf8_length,       true));
    EXPECT_FALSE(isUTF16((char const *) text_utf8bom,    text_utf8bom_length,    true));
    EXPECT_FALSE(isUTF16((char const *) text_utf16le,    text_utf16le_length,    true));
    EXPECT_FALSE(isUTF16((char const *) text_utf16lebom, text_utf16lebom_length, true));
    EXPECT_TRUE (isUTF16((char const *) text_utf16be,    text_utf16be_length,    true));
    EXPECT_TRUE (isUTF16((char const *) text_utf16bebom, text_utf16bebom_length, true));
}

//--------------------------------------------------------------
// Test the guessEncoding() function.
//--------------------------------------------------------------

TEST(MIME, guessEncoding) {
    auto f = [] (unsigned char const * text, size_t len) {
        std::stringstream s(std::string((char const *) text, len));
        return guessEncoding(s);
    };

    EXPECT_EQ(f(text_ascii,      text_ascii_length),      "ascii");
    EXPECT_EQ(f(text_utf8,       text_utf8_length),       "utf-8");
    EXPECT_EQ(f(text_utf8bom,    text_utf8bom_length),    "utf-8");
    EXPECT_EQ(f(text_utf16le,    text_utf16le_length),    "utf-16le");
    EXPECT_EQ(f(text_utf16lebom, text_utf16lebom_length), "utf-16le");
    EXPECT_EQ(f(text_utf16be,    text_utf16be_length),    "utf-16be");
    EXPECT_EQ(f(text_utf16bebom, text_utf16bebom_length), "utf-16be");
}

//--------------------------------------------------------------
// Test the getMimeType() function.
//--------------------------------------------------------------

TEST(MIME, getMimeType) {
    auto f1 = [] (char const * filename) {
        return getMimeType(filename, nullptr);
    };

    EXPECT_EQ(f1(".txt"),     "text/plain");
    EXPECT_EQ(f1(".gif"),     "image/gif");
    EXPECT_EQ(f1("test.txt"), "text/plain");
    EXPECT_EQ(f1("test.Txt"), "text/plain");
    EXPECT_EQ(f1("test.TXT"), "text/plain");
    EXPECT_EQ(f1("test.zip"), "application/zip");
    EXPECT_EQ(f1("test.zIp"), "application/zip");
    EXPECT_EQ(f1("test.ZIP"), "application/zip");
    EXPECT_EQ(f1("test.xxx"), "application/octet-stream");

    auto f2 = [] (unsigned char const * text, size_t len) {
        std::stringstream s(std::string((char const *) text, len));
        return getMimeType("test.html", &s);
    };

    EXPECT_EQ(f2(text_ascii,      text_ascii_length),      "text/html; charset=ascii");
    EXPECT_EQ(f2(text_utf8,       text_utf8_length),       "text/html; charset=utf-8");
    EXPECT_EQ(f2(text_utf8bom,    text_utf8bom_length),    "text/html; charset=utf-8");
    EXPECT_EQ(f2(text_utf16le,    text_utf16le_length),    "text/html; charset=utf-16le");
    EXPECT_EQ(f2(text_utf16lebom, text_utf16lebom_length), "text/html; charset=utf-16le");
    EXPECT_EQ(f2(text_utf16be,    text_utf16be_length),    "text/html; charset=utf-16be");
    EXPECT_EQ(f2(text_utf16bebom, text_utf16bebom_length), "text/html; charset=utf-16be");
}

//--------------------------------------------------------------
// Test the getFavoriteCompressionMode() function.
//--------------------------------------------------------------

TEST(MIME, favoriteCompressionMode) {
    EXPECT_EQ(getFavoriteCompressionMode("text/plain"),                         compression::brotli_text);
    EXPECT_EQ(getFavoriteCompressionMode("text/plain; charset=ASCII"),          compression::brotli_text);
    EXPECT_EQ(getFavoriteCompressionMode("text/plain ; charset=ASCII"),         compression::brotli_text);

    EXPECT_EQ(getFavoriteCompressionMode("application/zip"),                    compression::none);
    EXPECT_EQ(getFavoriteCompressionMode("application/zip; charset=UTF-16LE"),  compression::none);
    EXPECT_EQ(getFavoriteCompressionMode("application/zip ; charset=UTF-16LE"), compression::none);

    EXPECT_EQ(getFavoriteCompressionMode("unknown/unknown"),                    compression::none);
    EXPECT_EQ(getFavoriteCompressionMode("unknown/unknown; charset=UTF-8"),     compression::none);
    EXPECT_EQ(getFavoriteCompressionMode("unknown/unknown ; charset=UTF-8"),    compression::none);
}

//========================================================================
